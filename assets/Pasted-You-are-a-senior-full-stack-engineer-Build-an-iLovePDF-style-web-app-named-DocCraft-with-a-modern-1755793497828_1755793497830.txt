You are a senior full-stack engineer. Build an iLovePDF-style web app named "DocCraft" with a modern, minimal UI.

## Tech Stack
- Frontend: React 18 + Vite + TypeScript + Material UI (responsive, WCAG 2.1 AA)
- Backend: Node.js + Express + TypeScript
- Queue/Workers: BullMQ + Redis (optional toggle)
- Storage: Local temp + S3 for transient links
- Binaries (if available): Ghostscript (PDF compression), LibreOffice (PDF↔DOCX), Tesseract OCR
- Tests: Vitest (unit), Playwright (e2e)
- CI: GitHub Actions
- Error tracking: Sentry

## Monorepo Structure
- /apps/frontend: Vite React app with routes: / (tool hub), /merge, /split, /compress, /image-to-pdf, /pdf-to-image, /reorder
- /apps/backend: Express with REST endpoints and file upload (multer/busboy), rate limit, ClamAV scan, temp storage, signed S3 links
- /packages/ui: shared MUI components (UploadArea, FileList, OperationPanel, ProgressBar, ResultCard, ThemeProvider)
- /packages/lib: shared types, API client, validators (zod)
- /infra: GitHub Actions workflows, env samples, IaC placeholders

## Core Features (MVP)
1) Merge PDFs
2) Split PDF by ranges
3) Compress PDF (balanced/default, strong)
4) Image↔PDF (PNG/JPG to PDF, PDF to PNG/JPG)
5) Reorder/Rotate/Delete pages
- Drag & drop upload, multi-file select, file validation, progress & cancel
- After processing, return a single download with a one-time 15-minute URL; delete files immediately after download or TTL expiry

## API (examples)
POST /api/merge        -> input: array<file>; output: merged.pdf
POST /api/split        -> input: file + ranges string (e.g., "1-3,5,7-"); output: split.zip
POST /api/compress     -> input: file + level ("balanced"|"strong"); output: compressed.pdf
POST /api/pdf-to-image -> input: file + dpi; output: images.zip
POST /api/image-to-pdf -> input: files + order; output: combined.pdf
POST /api/reorder      -> input: file + newOrder + rotations; output: edited.pdf

## Non-Functional
- Rate limit: 60 rpm per IP; burst 120
- Max size: 25 MB/file, 10 files/batch, configurable via ENV
- Security: ClamAV scan on upload; strip metadata on export (optional)
- Privacy: no retention; files auto-delete after completion or 15 min TTL
- Observability: simple request logs + Sentry
- i18n: TR + EN with react-i18next

## Frontend UX Notes
- Page layout: Header (logo + Lang switch), ToolGrid on home with cards; Tool pages with a 3-step panel (Upload → Configure → Process)
- Components: UploadArea (drag & drop, list), OptionsPanel (e.g., compression level), ProcessButton, ProgressBar, ResultCard
- Theme: primary=purple/blue; rounded corners, subtle shadows; prefers-reduced-motion support

## Implementation Tasks (order)
1. Scaffold monorepo + Vite React TS + Express TS; add ESLint/Prettier
2. Set up MUI theme + basic routes + ToolGrid
3. Implement upload pipeline (frontend + multer), size/extension validation, error states
4. Implement /merge on backend using pdf-lib/hummus/ghostscript pipeline (choose best path); return merged stream
5. Add /split (page ranges parse), /compress (ghostscript flags), /image↔pdf (sharp/imagemagick), /reorder (qpdf/pdf-lib)
6. Add S3 signed URLs, TTL cleanup worker, delete temp files on complete
7. Add i18n (TR/EN), SEO basics (meta), analytics stub
8. Write unit/e2e tests for flows; set up CI
9. Prepare deployment configs for Vercel (frontend), Railway (backend)

## Deliverables
- Full source code in the folder structure above
- README with setup, .env.sample (S3, Redis, Sentry, limits)
- Test scripts (Vitest/Playwright) and CI pipeline
- Usage docs for each tool + known limitations
- Accessibility checklist (keyboard navigation, focus styles)

Follow clean code, strong typing, and include comments where external binaries are invoked. Ask before removing any feature behind a flag.
